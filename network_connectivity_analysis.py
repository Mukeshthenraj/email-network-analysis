# -*- coding: utf-8 -*-
"""network_connectivity_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/160J9zwzCXki6lRQUiRKDSHr5Os1XI3Uy

# Assignment 2 - Network Connectivity

In this assignment you will go through the process of importing and analyzing an internal email communication network between employees of a mid-sized manufacturing company.
Each node represents an employee and each directed edge between two nodes represents an individual email. The left node represents the sender and the right node represents the recipient. We will also store the timestamp of each email.
"""

import networkx as nx

#!head assets/email_network.txt

"""### Question 1

Using networkx, load up the directed multigraph from `assets/email_network.txt`. Make sure the node names are strings.

*This function should return a directed multigraph networkx graph.*
"""

def answer_one():
    import networkx as nx

    G = nx.read_edgelist('assets/email_network.txt',
                         delimiter='\t',
                         create_using=nx.MultiDiGraph(),
                         data=[('time', int)],
                         nodetype=str)
    return G

ans_one = answer_one()

print("Nodes:", len(ans_one.nodes()))
print("Edges:", len(ans_one.edges()))

"""### Question 2

How many employees are represented in the network?

How many `sender`->`recipient` pairs of employees are there in the network such that `sender` sent at least one email to `recipient`? Note that even if a `sender` sent multiple messages to a `recipient`, they should only be counted once. You should **not** exclude cases where an employee sent emails to themselves from this [email] count.

*This function should return a tuple with two integers (#employees, # `sender`->`recipient` pairs).*
"""

def answer_two():
    G = answer_one()
    num_employees = len(G.nodes())
    unique_pairs = len(set((u, v) for u, v in G.edges()))
    return (num_employees, unique_pairs)

ans_two = answer_two()

print("Number of employees:", ans_two[0])
print("Number of unique sender→recipient pairs:", ans_two[1])

"""### Question 3

* Part 1. Assume that information in this company can only be exchanged through email.

    When an employee sends an email to another employee, a communication channel has been created, allowing the sender to provide information to the reciever, but not viceversa.

    Based on the emails sent in the data, is it possible for information to go from every employee to every other employee?


* Part 2. Now assume that a communication channel established by an email allows information to be exchanged both ways.

    Based on the emails sent in the data, is it possible for information to go from every employee to every other employee?


*This function should return a tuple of bools (part1, part2).*
"""

def answer_three():
    G = answer_one()
    part1 = nx.is_strongly_connected(G)
    part2 = nx.is_weakly_connected(G)
    return (part1, part2)

ans_three = answer_three()

print("Can info go from every employee to every other (one-way)?", ans_three[0])
print("Can info go from every employee to every other (ignoring direction)?", ans_three[1])

"""### Question 4

How many nodes are in the largest weakly connected component of the graph?

*This function should return an int.*
"""

def answer_four():
    G = answer_one()
    largest_weak = max(nx.weakly_connected_components(G), key=len)
    return len(largest_weak)

ans_four = answer_four()

print("Question 4 answer: Number of nodes in the largest weakly connected component =", ans_four)

"""### Question 5

How many nodes are in the largest strongly connected component?

*This function should return an int*
"""

def answer_five():
    G = answer_one()
    largest_strong = max(nx.strongly_connected_components(G), key=len)
    return len(largest_strong)

ans_five = answer_five()

print("Question 5 answer: Number of nodes in the largest strongly connected component =", ans_five)

"""### Question 6

Using the NetworkX functions `strongly_connected_components` and `subgraph`, find the subgraph of nodes in the largest strongly connected component.
Call this graph G_sc.

*This function should return a networkx MultiDiGraph named G_sc.*
"""

def answer_six():
    G = answer_one()  # Load the full email graph
    # Get all strongly connected components
    sccs = nx.strongly_connected_components(G)
    # Find the largest one
    largest_scc = max(sccs, key=len)
    # Extract subgraph of just those nodes
    G_sc = G.subgraph(largest_scc).copy()
    return G_sc

ans_six = answer_six()
assert type(ans_six) == nx.MultiDiGraph , "Your return type should be a MultiDiGraph object"

print("Question 6 answer: G_sc is a subgraph with")
print("Number of nodes:", len(ans_six.nodes()))
print("Number of edges:", len(ans_six.edges()))
print("Graph type:", type(ans_six))

"""### Question 7

What is the average distance between nodes in G_sc?

*This function should return a float.*
"""

def answer_seven():
    G_sc = answer_six()  # Load the subgraph
    return nx.average_shortest_path_length(G_sc)  # Compute the average shortest distance

ans_seven = answer_seven()

print("Question 7 answer: Average distance between nodes in G_sc =", ans_seven)

"""### Question 8

What is the largest possible distance between two employees in G_sc?

*This function should return an int.*
"""

def answer_eight():
    G_sc = answer_six()  # Load the subgraph from Q6
    return nx.diameter(G_sc)  # Find the longest shortest path

ans_eight = answer_eight()

print("Question 8 answer: Diameter of G_sc =", ans_eight)

"""### Question 9

What is the set of nodes in G_sc with eccentricity equal to the diameter?

*This function should return a set of the node(s).*
"""

def answer_nine():
    G_sc = answer_six()
    return set(nx.periphery(G_sc))  # Returns all nodes with eccentricity = diameter

ans_nine = answer_nine()
assert type(ans_nine) == set, "Student answer must return a set"

print("Question 9 answer: Nodes with eccentricity equal to diameter:")
print(ans_nine)
print("Number of such nodes:", len(ans_nine))

"""### Question 10

What is the set of node(s) in G_sc with eccentricity equal to the radius?

*This function should return a set of the node(s).*
"""

def answer_ten():
    G_sc = answer_six()
    return set(nx.center(G_sc))  # Convert to set to satisfy Coursera test

ans_ten = answer_ten()
assert type(ans_ten) == set, "Student answer must return a set"

print("Question 10 answer: Nodes with eccentricity equal to radius (center):")
print(ans_ten)
print("Number of such nodes:", len(ans_ten))

"""### Question 11

Which node in G_sc has the most shortest paths to other nodes whose distance equal the diameter of G_sc?


For the node with the most such shortest paths, how many of these paths are there?


*This function should return a tuple (name of node, number of paths).*
"""

def answer_eleven():
    G_sc = answer_six()  # Load the strongly connected subgraph from Question 6
    diameter = nx.diameter(G_sc)  # Get the diameter (longest shortest path) of the graph

    max_paths = 0          # To track the highest number of diameter-length paths
    max_node = None        # To store the node with the most such paths

    # Loop through every node in the graph
    for node in G_sc.nodes():
        count = 0  # Count how many diameter-length paths start from this node

        # Check the shortest path from this node to every other node
        for target in G_sc.nodes():
            if node != target:  # Don't compare the node to itself
                try:
                    # If the shortest path from node → target equals the diameter, count it
                    if nx.shortest_path_length(G_sc, node, target) == diameter:
                        count += 1
                except nx.NetworkXNoPath:
                    # If there's no path (which shouldn't happen in a strongly connected graph), skip
                    continue

        # If this node has more diameter-length paths than the current max, update the record
        if count > max_paths:
            max_paths = count
            max_node = node

    # Return the node with the most diameter-length paths and the number of such paths
    return (max_node, max_paths)

ans_eleven = answer_eleven()
assert type(ans_eleven) == tuple, "Student answer must be a tuple"

print("Question 11 answer:")
print("Node with most diameter-length shortest paths:", ans_eleven[0])
print("Number of such paths:", ans_eleven[1])

"""### Question 12

Suppose you want to prevent communication flow from the node that you found in question 11 to node 10. What is the smallest number of nodes you would need to remove from the graph (you're not allowed to remove the node from the previous question or 10)?

*This function should return an integer.*
"""

def answer_twelve():
    G_sc = answer_six()
    source = answer_eleven()[0]  # Node from Q11
    target = '10'  # Fixed target node

    # Compute minimum number of nodes to cut off communication
    cut_set = nx.minimum_node_cut(G_sc, source, target)

    return len(cut_set)  # Return number of nodes to remove

ans_twelve = answer_twelve()

print("Question 12 answer: Minimum number of nodes to remove =", ans_twelve)

"""### Question 13

Convert the graph G_sc into an undirected graph by removing the direction of the edges of G_sc. Call the new graph G_un.


*This function should return a networkx Graph.*
"""

def answer_thirteen():
    G_sc = answer_six()                 # Load the directed strongly connected subgraph
    G_un = nx.Graph(G_sc)              # Convert to simple undirected Graph
    return G_un

ans_thirteen = answer_thirteen()
assert type(ans_thirteen) == nx.Graph , "Your return type should be a Graph object"

print("Question 13 answer: Undirected graph G_un")
print("Number of nodes:", len(ans_thirteen.nodes()))
print("Number of edges:", len(ans_thirteen.edges()))
print("Graph type:", type(ans_thirteen))

"""### Question 14

What is the transitivity and average clustering coefficient of graph G_un?

*This function should return a tuple (transitivity, avg clustering).*     
*Note: DO NOT round up your answer.*
"""

def answer_fourteen():
    G_un = answer_thirteen()  # Load undirected graph from Q13
    trans = nx.transitivity(G_un)  # Global clustering
    avg_clust = nx.average_clustering(G_un)  # Average local clustering
    return (trans, avg_clust)

ans_fourteen = answer_fourteen()
assert type(ans_fourteen) == tuple, "Student answer must be a tuple"

print("Question 14 answer:")
print("Transitivity:", ans_fourteen[0])
print("Average Clustering Coefficient:", ans_fourteen[1])

